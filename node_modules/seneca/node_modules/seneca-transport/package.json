{
  "name": "seneca-transport",
  "version": "0.2.6",
  "description": "Seneca transport",
  "main": "transport.js",
  "scripts": {
    "test": "./test.sh"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/rjrodger/seneca-transport.git"
  },
  "keywords": [
    "seneca",
    "transport",
    "plugin"
  ],
  "author": {
    "name": "Richard Rodger",
    "url": "http://richardrodger.com"
  },
  "license": "MIT",
  "dependencies": {
    "async": "~0.9.0",
    "connect": "~3.0.2",
    "connect-query": "^0.2.0",
    "connect-timeout": "^1.1.1",
    "gex": "~0.1.4",
    "jsonic": "^0.1.1",
    "lru-cache": "~2.5.0",
    "nid": "~0.3.2",
    "patrun": "~0.2.0",
    "reconnect-net": "0.0.0",
    "request": "~2.40.0",
    "underscore": "~1.6.0"
  },
  "devDependencies": {
    "mocha": "~1.20.1",
    "seneca-transport-test": "~0.1.2"
  },
  "files": [
    "README.md",
    "LICENSE.txt",
    "transport.js"
  ],
  "readme": "seneca-transport - a [Seneca](http://senecajs.org) plugin\n======================================================\n\n## Seneca Transport Plugin\n\nThis plugin provides the HTTP and TCP transport channels for\nmicro-service messages. It's a built-in dependency of the Seneca\nmodule, so you don't need to include it manually. You use this plugin\nto wire up your micro-services so that they can talk to each other.\n\n[![Build Status](https://travis-ci.org/rjrodger/seneca-transport.png?branch=master)](https://travis-ci.org/rjrodger/seneca-transport)\n\n[![NPM](https://nodei.co/npm/seneca-transport.png)](https://nodei.co/npm/seneca-transport/)\n[![NPM](https://nodei.co/npm-dl/seneca-transport.png)](https://nodei.co/npm-dl/seneca-transport/)\n\nFor a gentle introduction to Seneca itself, see the\n[senecajs.org](http://senecajs.org) site.\n\nIf you're using this plugin module, feel free to contact me on twitter if you\nhave any questions! :) [@rjrodger](http://twitter.com/rjrodger)\n\nCurrent Version: 0.2.6\n\nTested on: Seneca 0.5.20, Node 0.10.31\n\n\n### Install\n\nThis plugin module is included in the main Seneca module:\n\n```sh\nnpm install seneca\n```\n\nTo install separately, use:\n\n```sh\nnpm install seneca-transport\n```\n\n\n## Quick Example\n\nLet's do everything in one script to begin with. You'll define a\nsimple Seneca plugin that returns the hex value of color words. In\nfact, all it can handle is the color red!\n\nYou define the action pattern _color:red_, which aways returns the\nresult <code>{hex:'#FF0000'}</code>. You're also using the name of the\nfunction _color_ to define the name of the plugin (see [How to write a\nSeneca plugin](http://senecajs.org)).\n\n```js\nfunction color() {\n  this.add( 'color:red', function(args,done){\n    done(null, {hex:'#FF0000'});\n  })\n}\n```\n\nNow, let's create a server and client. The server Seneca instance will\nload the _color_ plugin and start a web server to listen for inbound\nmessages. The client Seneca instance will submit a _color:red_ message\nto the server.\n\n\n```js\nvar seneca = require('seneca')\n      \nseneca()\n  .use(color)\n  .listen()\n\nseneca()\n  .client()\n  .act('color:red')\n```\n\nYou can create multiple instances of Seneca inside the same Node.js\nprocess. They won't interfere with each other, but they will share\nexternal options from configuration files or the command line.\n\nIf you run the full script (full source is in\n[readme-color.js](https://github.com/rjrodger/seneca-transport/blob/master/test/readme-color.js)),\nyou'll see the standard Seneca startup log messages, but you won't see\nanything that tells you what the _color_ plugin is doing since this\ncode doesn't bother printing the result of the action. Let's use a\nfiltered log to output the inbound and outbound action messages from\neach Seneca instance so we can see what's going on. Run the script with:\n\n```sh\nnode readme-color.js --seneca.log=type:act,regex:color:red\n```\n\n_NOTE: when running the examples in this documentation, you'll find\nthat most of the Node.js processes do not exit. This because they\nrunning in server mode. You'll need to kill all the Node.js processes\nbetween execution runs. The quickest way to do this is:\n\n```sh\n$ killall node\n```\n_\n\n\nThis log filter restricts printed log entries to those that report\ninbound and outbound actions, and further, to those log lines that\nmatch the regular expression <code>/color:red/</code>. Here's what\nyou'll see:\n\n```sh\n[TIME] vy../..15/- DEBUG act -     - IN  485n.. color:red {color=red}   CLIENT \n[TIME] ly../..80/- DEBUG act color - IN  485n.. color:red {color=red}   f2rv..\n[TIME] ly../..80/- DEBUG act color - OUT 485n.. color:red {hex=#FF0000} f2rv..\n[TIME] vy../..15/- DEBUG act -     - OUT 485n.. color:red {hex=#FF0000} CLIENT\n```\n\nThe second field is the identifier of the Seneca instance. You can see\nthat first the client (with an identifier of _vy../..15/-_) sends the\nmessage <code>{color=red}</code>. The message is sent over HTTP to the\nserver (which has an identifier of _ly../..80/-_). The server performs the\naction, generating the result <code>{hex=#FF0000}</code>, and sending\nit back.\n\nThe third field, <code>DEBUG</code>, indicates the log level. The next\nfield, <code>act</code> indicates the type of the log entry. Since\nyou specified <code>type:act</code> in the log filter, you've got a\nmatch!\n\nThe next two fields indicate the plugin name and tag, in this case <code>color\n-</code>. The plugin is only known on the server side, so the client\njust indicates a blank entry with <code>-</code>. For more details on\nplugin names and tags, see [How to write a Seneca\nplugin](http://senecajs.org).\n\nThe next field (also known as the _case_) is either <code>IN</code> or\n<code>OUT</code>, and indicates the direction of the message. If you\nfollow the flow, you can see that the message is first inbound to the\nclient, and then inbound to the server (the client sends it\nonwards). The response is outbound from the server, and then outbound\nfrom the client (back to your own code). The field after that,\n<code>485n..</code>, is the message identifier. You can see that it\nremains the same over multiple Seneca instances. This helps you to\ndebug message flow.\n\nThe next two fields show the action pattern of the message\n<code>color:red</code>, followed by the actual data of the request\nmessage (when inbound), or the response message (when outbound).\n\nThe last field <code>f2rv..</code> is the internal identifier of the\naction function that acts on the message. On the client side, there is\nno action function, and this is indicated by the <code>CLIENT</code>\nmarker. If you'd like to match up the action function identifier to\nmessage executions, add a log filter to see them:\n\n```sh\nnode readme-color.js --seneca.log=type:act,regex:color:red \\\n--seneca.log=plugin:color,case:ADD\n[TIME] ly../..80/- DEBUG plugin color - ADD f2rv.. color:red\n[TIME] vy../..15/- DEBUG act    -     - IN  485n.. color:red {color=red}   CLIENT \n[TIME] ly../..80/- DEBUG act    color - IN  485n.. color:red {color=red}   f2rv..\n[TIME] ly../..80/- DEBUG act    color - OUT 485n.. color:red {hex=#FF0000} f2rv..\n[TIME] vy../..15/- DEBUG act    -     - OUT 485n.. color:red {hex=#FF0000} CLIENT\n```\n\nThe filter <code>plugin:color,case:ADD</code> picks out log entries of\ntype _plugin_, where the plugin has the name _color_, and where the\n_case_ is ADD. These entries indicate the action patterns that a\nplugin has registered. In this case, there's only one, _color:red_.\n\nYou've run this example in a single Node.js process up to now. Of\ncourse, the whole point is to run it a separate processes! Let's do\nthat. First, here's the server:\n\n```js\nfunction color() {\n  this.add( 'color:red', function(args,done){\n    done(null, {hex:'#FF0000'});\n  })\n}\n\nvar seneca = require('seneca')\n      \nseneca()\n  .use(color)\n  .listen()\n```\n\nRun this in one terminal window with:\n\n```sh\n$ node readme-color-service.js --seneca.log=type:act,regex:color:red\n```\n\nAnd on the client side:\n\n```js\nvar seneca = require('seneca')\n      \nseneca()\n  .client()\n  .act('color:red')\n```\n\nAnd run with:\n\n```sh\n$ node readme-color-client.js --seneca.log=type:act,regex:color:red\n```\n\nYou'll see the same log lines as before, just split over the two processes. The full source code is the [test folder](https://github.com/rjrodger/seneca-transport/tree/master/test).\n\n\n## Non-Seneca Clients\n\nThe default transport mechanism for messages is HTTP. This means you can communicate easily with a Seneca micro-service from other platforms. By default, the <code>listen</code> method starts a web server on port 10101, listening on all interfaces. If you run the _readme-color-service.js_ script again (as above), you can talk to it by _POSTing_ JSON data to the <code>/act</code> path. Here's an example using the command line _curl_ utility.\n\n```sh\n$ curl -d '{\"color\":\"red\"}' http://localhost:10101/act\n{\"hex\":\"#FF0000\"}\n```\n\nIf you dump the response headers, you'll see some additional headers that give you contextual information. Let's use the <code>-v</code> option of _curl_ to see them:\n\n```sh\n$ curl -d '{\"color\":\"red\"}' -v http://localhost:10101/act\n...\n* Connected to localhost (127.0.0.1) port 10101 (#0)\n> POST /act HTTP/1.1\n> User-Agent: curl/7.30.0\n> Host: localhost:10101\n> Accept: */*\n> Content-Length: 15\n> Content-Type: application/x-www-form-urlencoded\n> \n* upload completely sent off: 15 out of 15 bytes\n< HTTP/1.1 200 OK\n< Content-Type: application/json\n< Cache-Control: private, max-age=0, no-cache, no-store\n< Content-Length: 17\n< seneca-id: 9wu80xdsn1nu\n< seneca-kind: res\n< seneca-origin: curl/7.30.0\n< seneca-accept: sk5mjwcxxpvh/1409222334824/-\n< seneca-time-client-sent: 1409222493910\n< seneca-time-listen-recv: 1409222493910\n< seneca-time-listen-sent: 1409222493910\n< Date: Thu, 28 Aug 2014 10:41:33 GMT\n< Connection: keep-alive\n< \n* Connection #0 to host localhost left intact\n{\"hex\":\"#FF0000\"}\n```\n\nYou can get the message identifier from the _seneca-id_ header, and\nthe identifier of the Seneca instance from _seneca-accept_.\n\nThere are two structures that the submitted JSON document can take:\n\n   * Vanilla JSON containing your request message, plain and simple, as per the example above,\n   * OR: A JSON wrapper containing the client details along with the message data.\n\nThe JSON wrapper follows the standard form of Seneca messages used in\nother contexts, such as message queue transports. However, the simple\nvanilla format is perfectly valid and provided explicitly for\nintegration. The wrapper format is described below.\n\nIf you need Seneca to listen on a particular port or host, you can\nspecify these as options to the <code>listen</code> method. Both are\noptional.\n\n```js\nseneca()\n  .listen( { host:'192.168.1.2', port:80 } )\n```\n\nOn the client side, either with your own code, or the Seneca client,\nyou'll need to use matching host and port options.\n\n```bash\n$ curl -d '{\"color\":\"red\"}' http://192.168.1.2:80/act\n```\n\n```js\nseneca()\n  .client( { host:'192.168.1.2', port:80 } )\n```\n\nYou can also set the host and port via the Seneca options facility. When\nusing the options facility, you are setting the default options for\nall message transports. These can be overridden by arguments to individual\n<code>listen</code> and <code>client</code> calls.\n\nLet's run the color example again, but with a different port. On the server-side:\n\n```sh\n$ node readme-color-service.js --seneca.log=type:act,regex:color:red \\\n  --seneca.options.transport.port=8888\n```\n\nAnd the client-side:\n\n```sh\ncurl -d '{\"color\":\"red\"}' -v http://localhost:8888/act\n```\nOR\n\n```sh\n$ node readme-color-client.js --seneca.log=type:act,regex:color:red \\\n  --seneca.options.transport.port=8888\n```\n\n## Using the TCP Channel\n\nAlso included in this plugin is a TCP transport mechanism. The HTTP\nmechanism offers easy integration, but it is necessarily slower. The\nTCP transport opens a direct TCP connection to the server. The\nconnection remains open, avoiding connection overhead for each\nmessage. The client side of the TCP transport will also attempt to\nreconnect if the connection breaks, providing fault tolerance for\nserver restarts.\n\nTo use the TCP transport, specify a _type_ property to the\n<code>listen</code> and <code>client</code> methods, and give it the\nvalue _tcp_. Here's the single script example again:\n\n\n```js\nseneca()\n  .use(color)\n  .listen({type:'tcp'})\n\nseneca()\n  .client({type:'tcp'})\n  .act('color:red')\n```\n\nThe full source code is in the\n[readme-color-tcp.js](https://github.com/rjrodger/seneca-transport/blob/master/test/readme-color-tcp.js)\nfile. When you run this script it would be great to verify that the\nright transport channels are being created. You'd like to see the\nconfiguration, and any connections that occur. By default, this\ninformation is printed with a log level of _INFO_, so you will see it\nif you don't use any log filters.\n\nOf course, we are using a log filter. So let's add another one to\nprint the connection details so we can sanity check the system. We want\nto print any log entries with a log level of _INFO_. Here's the\ncommand:\n\n```sh\n$ node readme-color-tcp.js --seneca.log=level:INFO \\\n  --seneca.log=type:act,regex:color:red\n```\n\nThis produces the log output:\n\n```sh\n[TIME] 6g../..49/- INFO  hello  Seneca/0.5.20/6g../..49/-\n[TIME] f1../..79/- INFO  hello  Seneca/0.5.20/f1../..79/-\n[TIME] f1../..79/- DEBUG act    -         - IN  wdfw.. color:red {color=red} CLIENT \n[TIME] 6g../..49/- INFO  plugin transport - ACT b01d.. listen open {type=tcp,host=0.0.0.0,port=10201,...}\n[TIME] f1../..79/- INFO  plugin transport - ACT nid1.. client {type=tcp,host=0.0.0.0,port=10201,...} any\n[TIME] 6g../..49/- INFO  plugin transport - ACT b01d.. listen connection {type=tcp,host=0.0.0.0,port=10201,...} remote 127.0.0.1 52938\n[TIME] 6g../..49/- DEBUG act    color     - IN  bpwi.. color:red {color=red} mcx8i4slu68z UNGATE\n[TIME] 6g../..49/- DEBUG act    color     - OUT bpwi.. color:red {hex=#FF0000} mcx8i4slu68z\n[TIME] f1../..79/- DEBUG act    -         - OUT wdfw.. color:red {hex=#FF0000} CLIENT\n```\n\nThe inbound and outbound log entries are as before. In addition, you\ncan see the _INFO_ level entries. At startup, Seneca logs a \"hello\"\nentry with the identifier of the current instance execution. This\nidentifier has the form:\n<code>Seneca/[version]/[12-random-chars]/[timestamp]/[tag]</code>.  This\nidentifier can be used for debugging multi-process message flows. The\nsecond part is a local timestamp. The third is an optional tag, which\nyou could provide with <code>seneca({tag:'foo'})</code>, although we\ndon't use tags in this example.\n\nThere are three _INFO_ level entries of interest. On the server-side,\nthe listen facility logs the fact that it has opened a TCP port, and\nis now listening for connections. Then the client-side logs that it\nhas opened a connection to the server. And finally the server logs the\nsame thing.\n\nAs with the HTTP transport example above, you can split this code into\ntwo processes by separating the client and server code. Here's the server:\n\n```js\nfunction color() {\n  this.add( 'color:red', function(args,done){\n    done(null, {hex:'#FF0000'});\n  })\n}\n\nvar seneca = require('seneca')\n\nseneca()\n  .use(color)\n  .listen({type:'tcp'})\n```\n\nAnd here's the client:\n\n```js\nseneca()\n  .client({type:'tcp'})\n  .act('color:red')\n```\n\nYou can cheat by running the HTTP examples with the additional command\nline option: <code>--seneca.options.transport.type=tcp</code>.\n\nHTTP and TCP are not the only transport mechanisms available. Of\ncourse, in true Seneca-style, the other mechanisms are available as\nplugins. Here's the list.\n\n   * [redis-transport](https://github.com/rjrodger/seneca-redis-transport): uses redis for a pub-sub message distribution model\n   * [beanstalk-transport](https://github.com/rjrodger/seneca-beanstalk-transport): uses beanstalkd for a message queue\n   * [loadbalance-transport](https://github.com/mmalecki/seneca-loadbalance-transport): a load-balancing transport over multiple Seneca servers\n\nIf you're written your own transport plugin (see below for\ninstructions), and want to have it listed here, please submit a pull\nrequest.\n\n\n## Multiple Channels\n\nYou can use multiple <code>listen</code> and <code>client</code>\ndefinitions on the same Seneca instance, in any order. By default, a\nsingle <code>client</code> definition will send all unrecognized\naction patterns over the network. When you have multiple client\ndefinitions, it's becuase you want to send some action patterns to one\nmicro-service, and other patterns to other micro-services. To do this,\nyou need to specify the patterns you are interested in. In Seneca,\nthis is done with a _pin_.\n\nA Seneca _pin_ is a pattern for action patterns. You provide a list of\nproperty names and values that must match. Unlike ordinary action\npatterns, where the values are fixed, with a _pin_, you can use globs\nto match more than one value. For example, let's say you have the patterns:\n\n   * _foo:1,bar:zed-aaa_\n   * _foo:1,bar:zed-bbb_\n   * _foo:1,bar:zed-ccc_\n\nThen you can use these _pins_ to pick out the patterns you want:\n\n   * _foo:1_ matches _foo:1,bar:zed-aaa_; _foo:1,bar:zed-bbb_; _foo:1,bar:zed-ccc_\n   * _foo:1, bar:*_ also matches _foo:1,bar:zed-aaa_; _foo:1,bar:zed-bbb_; _foo:1,bar:zed-ccc_\n   * _foo:1, bar:*-aaa_ matches only _foo:1,bar:zed-aaa_\n\nLet's extend the color service example. You'll have three separate\nservices, all running in separate processes. They will listen on ports\n8081, 8082, and 8083 respectively. You'll use command line arguments\nfor settings. Here's the service code (see\n[readme-many-colors-server.js](https://github.com/rjrodger/seneca-transport/blob/master/test/readme-many-colors-server.js)):\n\n```js\nvar color  = process.argv[2]\nvar hexval = process.argv[3]\nvar port   = process.argv[4]\n\nvar seneca = require('seneca')\n\nseneca()\n\n  .add( 'color:'+color, function(args,done){\n    done(null, {hex:'#'+hexval});\n  })\n\n  .listen( port )\n\n  .log.info('color',color,hexval,port)\n```\n\nThis service takes in a color name, a color hexadecimal value, and a\nport number from the command line. You can also see how the <code>listen</code>\nmethod can take a single argument, the port number. To offer the\n_color:red_ service, run this script with:\n\n```sh\n$ node readme-many-colors-server.js red FF0000 8081\n```\n\nAnd you can test with:\n\n```sh\n$ curl -d '{\"color\":\"red\"}' http://localhost:8081/act\n```\n\nOf course, you need to use some log filters to pick out the activity\nyou're interested in. In this case, you've used a\n<code>log.info</code> call to dump out settings. You'll also want to\nsee the actions as the occur. Try this:\n\n```sh\nnode readme-many-colors-server.js red FF0000 8081 --seneca.log=level:info \\\n  --seneca.log=type:act,regex:color\n```\n\nAnd you'll get:\n\n```sh\n[TIME] mi../..66/- INFO  hello  Seneca/0.5.20/mi../..66/-\n[TIME] mi../..66/- INFO  color  red       FF0000 8081\n[TIME] mi../..66/- INFO  plugin transport -      ACT 7j.. listen {type=web,port=8081,host=0.0.0.0,path=/act,protocol=http,timeout=32778,msgprefix=seneca_,callmax=111111,msgidlen=12,role=transport,hook=listen}\n[TIME] mi../..66/- DEBUG act    -         -      IN  ux.. color:red {color=red} 9l..\n[TIME] mi../..66/- DEBUG act    -         -      OUT ux.. color:red {hex=#FF0000} 9l..\n```\n\nYou can see the custom _INFO_ log entry at the top, and also the transport\nsettings after that.\n\nLet's run three of these servers, one each for red, green and\nblue. Let's also run a client to connect to them.\n\nLet's make it interesting. The client will <code>listen</code> so that it can\nhandle incoming actions, and pass them on to the appropriate server by\nusing a _pin_. The client will also define a new action that can\naggregate color lookups.\n\n```js\nvar seneca = require('seneca')\n\nseneca()\n\n  // send matching actions out over the network\n  .client({ port:8081, pin:'color:red' })\n  .client({ port:8082, pin:'color:green' })\n  .client({ port:8083, pin:'color:blue' })\n\n  // an aggregration action that calls other actions\n  .add( 'list:colors', function( args, done ){\n    var seneca = this\n    var colors = {}\n\n    args.names.forEach(function( name ){\n      seneca.act({color:name}, function(err, result){\n        if( err ) return done(err);\n\n        colors[name] = result.hex\n        if( Object.keys(colors).length == args.names.length ) {\n          return done(null,colors)\n        }\n      })\n    })\n\n  })\n\n  .listen()\n\n  // this is a sanity check\n  .act({list:'colors',names:['blue','green','red']},console.log)\n```\n\nThis code calls the <code>client</code> method three times. Each time,\nit specifies an action pattern _pin_, and a destination port. And\naction submitted to this Seneca instance via the <code>act</code>\nmethod will be matched against these _pin_ patterns. If there is a\nmatch, they will not be processed locally. Instead they will be sent\nout over the network to the micro-service that deals with them.\n\nIn this code, you are using the default HTTP transport, and just\nchanging the port number to connect to. This reflects the fact that\neach color micro-service runs on a separate port.\n\nThe <code>listen<code> call at the bottom makes this \"client\" also\nlisten for inbound messages. So if you run, say the _color:red_\nservice, and also run the client, then you can send color:red messages\nto the client.\n\nYou need to run four processes:\n\n```sh\nnode readme-many-colors-server.js red FF0000 8081 --seneca.log=level:info --seneca.log=type:act,regex:color &\nnode readme-many-colors-server.js green 00FF00 8082 --seneca.log=level:info --seneca.log=type:act,regex:color &\nnode readme-many-colors-server.js blue 0000FF 8083 --seneca.log=level:info --seneca.log=type:act,regex:color &\nnode readme-many-colors-client.js --seneca.log=type:act,regex:CLIENT &\n\n```\n\nAnd then you can test with:\n\n```sh\n$ curl -d '{\"color\":\"red\"}' http://localhost:10101/act\n$ curl -d '{\"color\":\"green\"}' http://localhost:10101/act\n$ curl -d '{\"color\":\"blue\"}' http://localhost:10101/act\n```\n\nThese commands are all going via the client, which is listening on port 10101.\n\nThe client code also includes an aggregation action,\n_list:colors_. This lets you call multiple color actions and return\none result. This is a common micro-service pattern.\n\nThe script\n[readme-many-colors.sh](https://github.com/rjrodger/seneca-transport/blob/master/test/readme-many-colors.sh)\nwraps all this up into one place for you so that it is easy to run.\n\nSeneca does not require you to use message transports. You can run\neverything in one process. But when the time comes, and you need to\nscale, or you need to break out micro-services, you have the option to\ndo so.\n\n\n## Message Protocols\n\nThere is no message protocol as such, as the data representation of\nthe underlying message transport is used. However, the plain text\nmessage representation is JSON in all known transports.\n\nFor the HTTP transport, message data is encoded as per the HTTP\nprotocol. For the TCP transport, UTF8 JSON is used, with one\nwell-formed JSON object per line (with a single \"\\n\" as line\nterminator).\n\nFor other transports, please see the documentation for the underlying\nprotocol. In general the transport plugins, such as\n_seneca-redis-transport_ will handle this for you so that you only\nhave to think in terms of JavaScript objects\n\nThe JSON object is a wrapper for the message data. The wrapper contains\nsome tracking fields to make debugging easier, these are:\n\n   * _id_:     action identifier (appears in Seneca logs after IN/OUT)\n   * _kind_:   'act' for inbound actions, 'res' for outbound responses\n   * _origin_: identifier of orginating Seneca instance, where action is submitted\n   * _accept_: identifier of accepting Seneca instance, where action is performed\n   * _time_:\n      *   _client_sent_: client timestamp when message sent \n      *   _listen_recv_: server timestamp when message received \n      *   _listen_sent_: server timestamp when response sent \n      *   _client_recv_: client timestamp when response received \n   * _act_: action message data, as submitted to Seneca\n   * _res_: response message data, as provided by Seneca\n   * _error_: error message, if any\n   * _input_: input generating error, if any\n\n\n## Writing Your Own Transport\n\nTo write your own transport, the best approach is to copy one of the existing ones:\n\n   * [transport.js](https://github.com/rjrodger/seneca-transport/blob/master/transport.js): disconnected or point-to-point\n   * [redis-transport.js](https://github.com/rjrodger/seneca-redis-transport/blob/master/redis-transport.js): publish/subscribe\n   * [beanstalk-transport.js](https://github.com/rjrodger/seneca-beanstalk-transport/blob/master/beanstalk-transport.js): message queue\n\nChoose a _type_ for your transport, say \"foo\". You will need to\nimplement two patterns:\n\n   * role:transport, hook:listen, type:foo\n   * role:transport, hook:client, type:foo\n\nTo implement the client, use the template:\n\n```js\nvar transport_utils = seneca.export('transport/utils')\n\nfunction hook_client_redis( args, clientdone ) {\n  var seneca         = this\n  var type           = args.type\n\n  // get your transport type default options\n  var client_options = seneca.util.clean(_.extend({},options[type],args))\n\n  transport_utils.make_client( make_send, client_options, clientdone )\n\n  // implement your transport here\n  function make_send( spec, topic, send_done ) {\n    // see an existing transport for full details\n  }\n}  \n```\n\nTo implement the server, use the template:\n\n```js\nvar transport_utils = seneca.export('transport/utils')\n\nfunction hook_listen_redis( args, done ) {\n  var seneca         = this\n  var type           = args.type\n\n  // get your transport type default options\n  var listen_options = seneca.util.clean(_.extend({},options[type],args))\n\n  // get inbound data, and...\n  transport_utils.handle_request( seneca, data, listen_options, function(out){\n    // see an existing transport for full details\n\n  })\n}\n```\n\nMessage transport code should be written very carefully as it will be\nsubject to high load and many error conditions - have fun!\n\n\n\n## Plugin Options\n\nThe transport plugin family uses an extension to the normal Seneca\noptions facility. As well as supporting the standard method for\ndefining options (see [How to Write a\nPlugin](http://senecajs.org/write-a-plugin.html#wp-options)), you can\nalso supply options via arguments to the <code>client</code> or\n<code>listen</code> methods, and via the type name of the transport\nunder the top-level _transport_ property.\n\nThe primary options are:\n  \n   * _msgprefix_: a string to prefix to topic names so that they are namespaced\n   * _callmax_: the maximum number of in-flight request/response messages to cache\n   * _msgidlen_: length of the message indentifier string\n\nThese can be set within the top-level _transport_ property of the main\nSeneca options tree:\n\n```js\nvar seneca = require('seneca')\nseneca({\n  transport:{\n    msgprefix:'foo'\n  }\n})\n```\n\nEach transport type forms a sub-level within the _transport_\noption. The recognized types depend on the transport plugins you have\nloaded. By default, _web_ and _tcp_ are available. To use _redis_, for example, you\nneed to do this:\n\n```js\nvar seneca = require('seneca')\nseneca({\n    transport:{\n      redis:{\n        timeout:500\n      }\n    }\n  })\n\n  // assumes npm install seneca-redis-transport\n  .use('redis-transport')\n\n  .listen({type:'redis'})\n```\n\nYou can set transport-level options inside the type property:\n\n```js\nvar seneca = require('seneca')\nseneca({\n  transport:{\n    tcp:{\n      timeout:1000\n    }\n  }\n})\n```\n\nThe transport-level options vary by transport. Here are the default ones for HTTP:\n\n   * _type_: type name; constant: 'web'\n   * _port_: port number; default: 10101\n   * _host_: hostname; default: '0.0.0.0' (all interfaces)\n   * _path_: URL path to submit messages; default: '/act'\n   * _protocol_: HTTP protocol; default 'http'\n   * _timeout_: timeout in milliseconds; default: 5555\n\nAnd for TCP:\n\n   * _type_: type name; constant: 'tcp'\n   * _port_: port number; default: 10201\n   * _host_: hostname; default: '0.0.0.0' (all interfaces)\n   * _timeout_: timeout in milliseconds; default: 5555\n\nThe <code>client</code> and <code>listen</code> methods accept an\noptions object as the primary way to specify options:\n\n```js\nvar seneca = require('seneca')\nseneca()\n  .client({timeout:1000})\n  .listen({timeout:2000})\n```\n\nAs a convenience, you can specify the port and host as optional arguments:\n\n```js\nvar seneca = require('seneca')\nseneca()\n  .client( 8080 )\n  .listen( 9090, 'localhost')\n```\n\nTo see the options actually in use at any time, you can call the\n<code>seneca.options()</code> method. Or try\n\n```sh\n$ node seneca-script.js --seneca.log=type:options\n```\n\n## Testing\n\nThis module itself does not contain any direct reference to Seneca, as\nit is a Seneca dependency. However, Seneca is needed to test it, so\nthe test script will perform an _npm install seneca_ (if needed). This is not\nsaved to _package.json_.\n\n```sh\nnpm test\n```\n\n\n## Releases\n\n   * 0.2.6: fixed error transmit bug https://github.com/rjrodger/seneca/issues/63\n\n\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rjrodger/seneca-transport/issues"
  },
  "homepage": "https://github.com/rjrodger/seneca-transport",
  "_id": "seneca-transport@0.2.6",
  "dist": {
    "shasum": "c662f9c4c7dc71d9a5ad72c0ce76d229cd767326"
  },
  "_from": "seneca-transport@~0.2.5",
  "_resolved": "http://registry.npmjs.org/seneca-transport/-/seneca-transport-0.2.6.tgz"
}
