{
  "name": "parambulator",
  "description": "A simple way to generate nice error messages for named parameters.",
  "keywords": [
    "json",
    "param",
    "arg",
    "parameter",
    "argument",
    "schema"
  ],
  "homepage": "https://github.com/rjrodger/parambulator",
  "author": {
    "name": "Richard Rodger",
    "url": "http://richardrodger.com/"
  },
  "contributors": [
    {
      "name": "Richard Rodger",
      "url": "http://richardrodger.com/"
    }
  ],
  "version": "1.2.1",
  "main": "parambulator.js",
  "repository": {
    "url": "https://github.com/rjrodger/parambulator.git"
  },
  "dependencies": {
    "underscore": "~1.6.0",
    "gex": "~0.1.4",
    "jsonic": "~0.1.1"
  },
  "files": [
    "package.json",
    "LICENSE.txt",
    "README.md",
    "parambulator.js"
  ],
  "devDependencies": {
    "chai": "~1.9.1",
    "jasmine-node": "~1.14.3",
    "mocha": "~1.18.2",
    "phantomjs": "~1.9.7-5",
    "uglify-js": "~2.4.13"
  },
  "scripts": {
    "test": "jasmine-node ./test/parambulator.spec.js",
    "browser": "phantomjs test/run-jasmine.js test/jasmine.html",
    "build": "uglifyjs parambulator.js -c \"evaluate=false\" -m --source-map parambulator-min.map -o parambulator-min.js",
    "prepublish": "npm run-script build && npm test && npm run-script browser"
  },
  "readme": "# parambulator - Node.js module\n\n\nA simple way to generate nice error messages for named parameters.\n\nThis module is used by the <a href=\"http://senecajs.org\">Seneca framework</a> for input validation.\n\nIf you're using this module, feel free to contact me on twitter if you have any questions! :) [@rjrodger](http://twitter.com/rjrodger)\n\nCurrent Version: 1.2.1\n\nTested on: Node 0.10.31, Chrome 37\n\n\nUse this module to validate input or configuration parameters provided\nas JSON. You can ensure that the JSON structure and data types are\nwhat you need. You'll get friendly, useful error messages for your\nusers, and that makes your API better!\n\n```javascript\nvar parambulator = require('parambulator')\n\nvar paramcheck = parambulator({ \n  price: {type$:'number'}\n})\n\n// this passes\nparamcheck.validate( { price: 10.99 }, function(err) { console.log(err) } )\n\n// this fails - price should be a number\nparamcheck.validate( { price: 'free!' }, function(err) { console.log(err) } )\n// output: The value 'free!' is not of type 'number' (parent: price). \n```\n\n_Why?_\n\nYou're writing a module and you accept configuration as a structured\nJavaScript object. For example, opening a database connection:\n[MongoDB driver](http://mongodb.github.com/node-mongodb-native/api-generated/server.html). Or\nyou want to have named parameters:\n[http.request](http://nodejs.org/api/http.html#http_http_request_options_callback).\n\nIt's nice to be able to validate the input and provide useful error messages, without hand-coding the validation.\n\n\n_But What About JSONSchema!_\n\nYes, [JSONSchema](http://json-schema.org) would be the proper way to do this. But the syntax is too hard, and the error messages aren't friendly. This is a [Worse is Better!](http://www.jwz.org/doc/worse-is-better.html) approach.\n\nThere's also a philosophical difference. JSONSchema defines a formal structure, so you need to be fairly precise and complete. Parambulator defines a list of rules that are tested in the order you specify, and you can be vague and incomplete.\n\n\nKey Features:\n\n   * Easy syntax, rules are tested in order\n   * Add your own rules\n   * Customize the error messages\n   \nAnd yes Virginia, it does [validate its own input](http://en.wikipedia.org/wiki/Self-hosting).\n\n\n## Installation\n\n    npm install parambulator\n\nor\n\n    bower install parambulator\n\n\nAnd in your code:\n\n    var parambulator = require('parambulator')\n\nor\n\n    <script src=\"bower_components/parambulator/parambulator-min.js\"></script>\n\n\n## Usage\n\nImport the module using the standard _require_ syntax:\n\n```javascript\nvar parambulator = require('parambulator')\n```\n\nThis is a function that creates _Parambulator_ object instances. This function accepts two arguments:\n\n   * _spec_ - the rule specification to test against\n   * _pref_ - your preferences, such as custom error messages and rules\n\nExample:\n\n```javascript\nvar paramcheck = parambulator({ price: {type$:'number'} })\n```\n\n\nThe _paramcheck_ variable is an instance of _Parambulator_. This object only has one method: _validate_, which accepts two arguments:\n\n   * _args_: the object to validate\n   * _cb_: a callback function, following the standard Node.js error convention (first arg is an Error)\n\nExample:\n\n```javascript\nparamcheck.validate( { price: 10.99 }, function(err) { console.log(err) } )\n```\n\n\nThe callback function is called when the validation has completed. Processing of rules stops as soon as a rule fails. If validation fails, the first argument to the callback will be a standard JavaScript _Error_ object, with an error message in the _message_ property.\n\n\n### Examples\n\nHeavily commented examples are provided in the _doc/examples_ folder: https://github.com/rjrodger/parambulator/tree/master/doc/examples\n\nYou should probably read this rest of this first, though. \n\n\n### Rules\n\nThe validation rules are defined in the _spec_ argument to _parambulator_. The rules are specified as an object, the properties of which are the rule names, and the values the rule options, like so: `{required$:['foo','bar']}`. The rules are executed in the order that they appear (JavaScript preserves the order of object properties).\n\nRule names always end with a `$` character. Properties that do not end with `$` are considered to be literal property names:\n\n```javascript\n{\n  required$: ['foo','bar'],\n  foo: {\n    type$: 'string'\n  }\n}\n```\n\nThis specification requires the input object to have two properties, _foo_ and _bar_, and for the _foo_ property to have a string value. For example, this is valid:\n\n```javascript\n{ foo:'hello', bar:1 }\n```\n\nBut these are not:\n```javascript\n{ foo:1, bar:1 }  // foo is not a string\n{ foo:'hello' }   // bar is missing\n```\n\nThe rules are evaluated in the order they appear:\n\n   1. at the current property (i.e. the top level), check for properties _foo_ and _bar_, as per `required$: ['foo','bar']`\n   2. descend into the _foo_ property, and check that it's value is of `type$: 'string'` \n\nYou can nest rules within other rules. They will be evaluated in the order they appear, depth first.\n\nFor each input property, the rules apply to the value or values within that property. This means that your rule specification mirrors the structure of the input object.\n\nFor example, the specification:\n\n```javascript\n{\n  foo: {\n    bar: { type$: 'integer' }\n  }\n}\n```\n\nmatches\n\n```javascript\n{ foo: { bar: 1 } }\n```\n\nbut does not match\n\n```javascript\n{ bar: { foo: 1 } }\n```\n\nIn general, rules are permissive, in that they only apply if a given property is present. You need to use the _required$_ rule to require that a property is always present in the input.\n\nEach rule has a specific set of options relevant to that rule. For example, the _required$_ rule takes an array of property names. The type$ rule takes a string indicating the expected type: _string_, _number_, _boolean_, etc. For full details, see the rule descriptions below.\n\nLiteral properties can also accept a wildcard string expression. For example:\n\n```javascript\n{ foo: \"ba*\" }\n```\n\nThis matches:\n\n```javascript\n{ foo: \"ba\" }\n{ foo: \"bar\" }\n{ foo: \"barx\" }\n```\n\nbut not\n\n```javascript\n{ foo: \"b\" }\n```\n\n\n\n### Wildcards\n\nSometimes you don't know the property names in advance. To handle this case, you can also use wildcard expressions in literal properties:\n\n```javascript\n{ 'a*': { type$: 'boolean' } }\n```\n\nThis matches:\n\n```javascript\n{\n  a: true,\n  ax: false,\n  ayz: true\n}\n```\n\nIn particular, `'*'` on its own will match any property (at the same level). Wildcard expressions have the usual syntax: `*` means match anything, and `?` means match a single character.\n\n\nWhat about repeatedly nested rules? In this situation, you want to apply the same set of rules at any depth. You can use the special literal property `'**'` to achieve this:\n\n```javascript\n{ '**': { a: {type$: 'boolean' } } }\n```\n\nThis matches:\n\n```javascript\n{ a:true, x:{a:false, y:{a:true}}}\n```\n\nensuring that any properties called _a_ will be an integer. The recursive descent starts from the current level.\n\n\n### Arrays\n\nArrays are treated as if they were objects. The property names are simply the string values of the integer array indexes. For example:\n\n```javascript\n{ a: {'0':'first'} }\n```\n\nThis matches:\n\n```javascript\n{ a:['first'] } \n```\n\nDue to a quirk in the Chrome V8 engine, the order of integer properties is not preserved. Use the special prefix `__` as a workaround:\n\n```javascript\n{ a: {'__1':'first', '__0':'second'} }\n```\n\nThis matches:\n\n```javascript\n{ a:['second','first'] } \n```\n\nbut the rules are tested in order:\n\n   1. `'__1':'first'`\n   2. `'__0':'second'`\n\n\n\n### Custom Errors\n\nEach rule has an associated error message. By default these explain the reason why a rule failed, and give the property path (in standard JavaScript dot syntax: `foo.bar.baz`) of the offending value. You can customize these error messages, by providing your own string templates, or by providing a function that returns the error message text.\n\nUse the _msgs_ property of the _pref_ argument (the second argument to _parambulator_) to define custom error messages:\n\n```javascript\nvar pm = parambulator({...},{\n  msgs: {\n     required$: 'Property <%=property%> is required, yo!'\n  }\n})\n```\n\nThe template syntax is provided by the _underscore_ module: http://underscorejs.org/#template\n\nThe following properties are available:\n\n   * _property_: the relevant property name\n   * _value_: the string representation of the value that failed in some way\n   * _point_: the actual value, which could be of any type, not just a string\n   * _rule.name_: the name of the rule \n   * _rule.spec_: the rule specification, e.g. `'boolean'` for rule `type$:'boolean'` \n   * _parentpath_: a string locating the value in the input (properties in dot-syntax)\n   * _json_: a reference to the JSON.stringify function, use like so: <%=json(rule.spec)%>\n\nThe _parentpath_ will use the term _top level_ when the error concerns\nthe top level of the input object. You can customize this term using the _topname_ option:\n\n```javascript\nvar pm = parambulator({...},{\n  topname: 'name_of_param_in_my_function_definition'\n})\n```\n\nYou can also modify the error message using the _msgprefix_ and\n_msgsuffix_ options, which are prepended and appended to the message\nbody, respectively, and also support the template syntax.\n\n\nYou can also specify a custom error message using a function. This\nlets you customize on the specific failing conditions, such as the\nproperty name:\n\n```javascript\nvar pm = parambulator({...},{\n  msgs: {\n     required$: function(inserts){\n        if( 'voodoo' == inserts.property ) {\n          return \"don't dare do: \"+inserts.value\n        }\n        else {\n          return 'Property '+inserts.property+' is required, yo!'\n        }\n     }\n  }\n})\n```\n\nThe _inserts_ parameter is an object containing the properties as above.\n\n\n## Rules\n\nThe following rules are provided out-of-the-box. To define your own rules, see below.\n\nEach rule operates at the current _point_. This is the current property location inside the input object.\n\nFor example, with input:\n\n```javascript\n{\n  foo: {\n    bar: {\n      baz: 'zzz'\n    }\n  }\n}\n```\n\nthe _point_ `foo.bar` is the object:\n\n```javascript\n{ baz: 'zzz'} \n```\n\n\n### literal property\n\nMatch an input property. You can use wildcards. Accepts a set of sub rules, or a wildcard string to match against. The property names match against property names in the current point.\n\n```javascript\n{\n  a:    { ... }\n  'b*': { ... }\n  c:    'z*'\n}\n```\n\n\n### boolean rules\n\nAs a convenience, rules that take a property name, such as _required$_, can be specified for a property using the form:\n\n```javascript\n{\n  foo: 'required$',\n  bar: 'required$,string$'\n}\n```\n\nTo use a _$_ symbol literally, use the form:\n\n```javascript\n{\n  foo: { eq$:'text containing $' }\n}\n```\n\n\n### atmostone$\n\nAccept at most one of a list of properties. Accepts an array of property name strings. At most one of them can be present in the current point.\n\n```javascript\n{\n  atmostone$: ['foo','bar']\n}\n```\n\n\n### exactlyone$\n\nAccept exactly one of a list of properties. Accepts an array of property name strings. Exactly one of them must be present in the current point.\n\n```javascript\n{\n  exactlyone$: ['foo','bar']\n}\n```\n\n\n### atleastone$\n\nAccept at least one of a list of properties. Accepts an array of property name strings. At least one of them must be present in the current point.\n\n```javascript\n{\n  atleastone$: ['foo','bar']\n}\n```\n\n\n\n### required$\n\nSpecify a set of required properties. Accepts an array of property name strings, or a single property name. Wildcards can be used. All properties must be present in the current point. Can also appear as a rule specification for literal properties.\n\n\n```javascript\n{ required$: ['foo','b*'] } // wildcards work too!\n{ required$: 'bar' }        // for convenience\n{ bar: 'required$' }        // for extra convenience\n{ bar: {required$:true} }   // for extra extra convenience\n{ 'b*': 'required$' }       // and that's just nice\n```\n\n\n### notempty$\n\nSpecify a set of properties that cannot be empty, if they are present. Unlike _required$_, these properties can be absent altogether, so use _required$_ if they are also required! Accepts an array of property name strings, or a single property name. Wildcards can be used. All properties are relative to the current point. Can also appear as a rule specification for literal properties.\n\n```javascript\n{ notempty$: ['foo','b*'] } // wildcards work too!\n{ notempty$: 'bar' }        // for convenience\n{ bar: 'notempty$' }        // for extra convenience\n{ 'b*': 'notempty$' }       // and that's just nice, again\n```\n\n### wild$\n\nSpecify a wildcard pattern that the property value must match. The property value does not need to be a string. See the [gex](https://github.com/rjrodger/gex) module documentation.\n\n```javascript\n{ foo: {wild$:'b*'} } \n```\n\n### re$\n\nSpecify a regular expression that the property value must match. The property value is converted to a string. The regular epxression is given as-is, or can be in the format /.../X, where X is a modifier such as _i_.\n\n```javascript\n{ \n  foo: {re$:'a.*'}, \n  bar: {re$:'/b/i'} \n} \n```\n\n\n### type$\n\nCheck that a property value is of a given JavaScript type. Does not require the property to be present (use _required$_ for that). Can only be used as a subrule of a literal property.\n\n```javascript\n{ \n  a: {type$:'string'}, \n  b: {type$:'number'}, \n  c: {type$:'integer'}, // can't be decimal! \n  d: {type$:'boolean'}, \n  e: {type$:'date'}, \n  f: {type$:'array'}, \n  g: {type$:'object'}, \n  h: {type$:'function'}\n} \n```\n\nAs a convenience, the type rules can also be used in the form:\n\n```javascript\n{\n  $string: 'propname'\n}\n```\n\n\n### eq$\n\nCheck that a property value is an exactly equal to the given value (must also match type).\n\n```javascript\n{ \n  foo: {eq$:'bar'}, \n}\n```\n\n### comparisons\n\nThe following comparison rules can be used:\n\n   * _lt$_: less than\n   * _lte$_: less than or equal to (alias: max$)\n   * _gt$_: greater than\n   * _gte$_: greater than or equal to (alias: min$)\n   * _gt$_: greater than\n\nFor example:\n\n```javascript\n{ \n  foo: {lt$:100}, \n}\n```\n\nComparisons also work on alphabetically on strings.\n\n\n\n### enum$\n\nCheck that a property value is one of an enumerated list of values (can be of any type).\n\n```javascript\n{ \n  color: {enum$:['red','green','blue']}, \n}\n```\n\n\n### uniq$\n\nCheck that a list contains only unique properties.\n\n```javascript\n{ \n  rainbow: 'uniq$'\n}\n```\n\nThe above specification validates:\n\n```javascript\n{ \n  rainbow: ['red','orange','yellow','green','blue','indigo','violet']\n}\n```\n\nBut does not validate:\n\n```javascript\n{ \n  rainbow: ['red','red','red','red','red','red','red']\n}\n```\n\n\n### only$\n\nCheck that a property _name_ is one of an enumerated list of names, at this point\n\n```javascript\n{ \n  options: {only$:['folder','duration','limit']}, \n}\n```\n\n\n\n### ** recursion\n\nApply a set of subrules recursively to the current point and all it's children.\n\n```javascript\n{ \n  a: {\n    '**': {\n      b: { type$:'integer' }\n    }, \n  }\n}\n```\n\n\n## Custom Rules\n\nYou can write your own rules if you need additional validation. The [range.js](https://github.com/rjrodger/parambulator/blob/master/doc/examples/range.js) example shows you how.\n\nDefine your own rules inside the _rules_ property of the _prefs_ argument to _paramabulator_. Each rule is just a function, for example:\n\n```javascript\nvar pm = parambulator({...},{\n  rules: {\n     mynewrule$: function(ctxt,cb){\n       ...\n     }\n  }\n})\n```\n\nDont forget the `$` suffix!\n\nThe _ctxt_ parameter provides the same interface as the _inserts_ object for custom messages (as above). You can execute callback or evented code inside the rule function. Call the _cb_ callback without any arguments if the rule passes. \n\nIf the rule fails, you can use a utility function to generate an error message:\n\n```javascript\nreturn ctxt.util.fail(ctxt,cb)\n```\n\nJust ensure you have a custom message with the same name as the rule!\n\nThe built-in rule definitions in [parambulator.js](https://github.com/rjrodger/parambulator/blob/master/parambulator.js) are also a good resource.\n\nTweet me [@rjrodger](http://twitter.com/rjrodger) if you get stuck.\n\nBy the way, if you have a cool new rule and you thing it should be built-in, send me a pull request! Just follow the pattern for, say, _wild$_ in [parambulator.js](https://github.com/rjrodger/parambulator/blob/master/parambulator.js). You'll need entries in _rulemap_, _msgsmap_, and _ownparams_.\n\n\n\n### Validation of Custom Rules\n\nWhen you define a custom rule, you'll want to ensure that rule specifications using it are valid. You can do this by adding validation rules to the optional _valid_ property of the _prefs_ argument.\n\nThe [range.js](https://github.com/rjrodger/parambulator/blob/master/doc/examples/range.js) example also shows you how to do this.\n\nThere is a gotcha. You need to escape the rule names, so that they are treated as literal properties, and not rules. To do this, use the `prop$` pseudo-rule:\n\n```javascript\n{ prop$: {name:'foo', rules:{type$:'string'}} }\n```\n\nis equivalent to:\n\n```javascript\n{ foo: {type$:'string'} }\n```\n\nThe other pseudo-rule that may come in handy is the `list$` rule. This lets you specify rules using an array. Each element is a sub array with two elements, the first is the rule name, and the second the rule specification\n\n```javascript\n{\n  list$: [\n    ['foo', {type$:'string'}],\n    ['bar', {type$:'string'}],\n  ]\n}\n```\n\nTake a look at the definition of `ownparams` in [parambulator.js](https://github.com/rjrodger/parambulator/blob/master/parambulator.js) to see how _parambulator_ validates its own input.\n\n\n\n\n## Testing\n\nTests run on the command line, in a headless browser, and in a normal browser:\n\n```sh\n$ npm build\n$ npm test\n$ npm run browser\n$ open test/jasmine.html\n```\n\n## Releases\n\nRelease numbers are strict [semver](http://semver.org/) as 1.x.x. All\nreleases are tagged in github with release version.\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rjrodger/parambulator/issues"
  },
  "_id": "parambulator@1.2.1",
  "dist": {
    "shasum": "e7fd625fe5fc541d22d5d8bd4853a336e6a13631"
  },
  "_from": "parambulator@~1.2.1",
  "_resolved": "http://registry.npmjs.org/parambulator/-/parambulator-1.2.1.tgz"
}
