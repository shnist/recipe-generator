{
  "name": "patrun",
  "description": "A fast pattern matcher on JavaScript object properties.",
  "homepage": "https://github.com/rjrodger/patrun",
  "keywords": [
    "pattern",
    "matcher",
    "object",
    "property",
    "json"
  ],
  "author": {
    "name": "Richard Rodger",
    "url": "http://richardrodger.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/rjrodger/patrun.git"
  },
  "main": "patrun.js",
  "version": "0.2.0",
  "scripts": {
    "test": "jasmine-node ./test",
    "browser": "phantomjs test/run-jasmine.js test/jasmine.html",
    "build": "jshint patrun.js; uglifyjs patrun.js -c \"evaluate=false\" --comments \"/ Copyright .*/\" -m --source-map patrun-min.map -o patrun-min.js"
  },
  "license": "MIT",
  "files": [
    "patrun.js",
    "patrun-min.js",
    "patrun-min.map",
    "LICENSE"
  ],
  "devDependencies": {
    "jasmine-node": "~1.14.3",
    "jshint": "~2.5.1",
    "benchmark": "~1.0.0"
  },
  "dependencies": {
    "underscore": "~1.6.0",
    "gex": "~0.1.4"
  },
  "readme": "# patrun\n\n### A fast pattern matcher on JavaScript object properties. \n\nNeed to pick out an object based on a subset of it's properties? Say you've got:\n\n```JavaScript\n{ x:1,     } -> A\n{ x:1, y:1 } -> B\n{ x:1, y:2 } -> C\n```\n\nThen patrun can give you the following results:\n\n```JavaScript\n{ x:1 }      -> A\n{ x:2 }      -> no match\n{ x:1, y:1 } -> B\n{ x:1, y:2 } -> C\n{ x:2, y:2 } -> no match\n{ y:1 }      -> no match\n```\n\nIt's basically _query-by-example_ for property sets.\n\nThis module is used by the [Seneca](http://senecajs.org) framework to pattern match actions.\n\n\n\n### Support\n\nIf you're using this library, feel free to contact me on twitter if you have any questions! :) [@rjrodger](http://twitter.com/rjrodger)\n\nThis module works on both Node.js and browsers.\n\nCurrent Version: 0.2.0\n\nTested on: Node.js 0.10.26, Chrome 35, Firefox 29, Safari 5.1.10, Opera 12.16\n\n[![Build Status](https://travis-ci.org/rjrodger/patrun.png?branch=master)](https://travis-ci.org/rjrodger/patrun)\n\n\n\n### Quick example\n\nHere's how you register some patterns, and then search for matches:\n\n```JavaScript\nvar patrun = require('patrun')\n\nvar pm = patrun()\n      .add({a:1},'A')\n      .add({b:2},'B')\n\n// prints A\nconsole.log( pm.find({a:1}) ) \n\n// prints null\nconsole.log( pm.find({a:2}) ) \n\n// prints A, b:1 is ignored, it was never registered\nconsole.log( pm.find({a:1,b:1}) ) \n\n// prints B, c:3 is ignored, it was never registered\nconsole.log( pm.find({b:2,c:3}) ) \n```\n\nYou're matching a subset, so your input can contain any number of other properties.\n\n\n## Install\n\nFor Node.js:\n\n```sh\nnpm install jsonic\n```\n\nFor Bower:\n\n```sh\nbower install patrun\n```\n\n\n# The Why\n\nThis module lets you build a simple decision tree so you can avoid\nwriting _if_ statements. It tries to make the minimum number of\ncomparisons necessary to pick out the most specific match.\n\nThis is very useful for handling situations where you have lots of\n\"cases\", some of which have \"sub-cases\", and even \"sub-sub-sub-cases\".\n\nFor example, here are some sales tax rules:\n\n   * default: no sales tax\n   * here's a list of countries with known rates: Ireland: 23%, UK: 20%, Germany: 19%, ...\n   * but wait, that's only standard rates, here's [the other rates](http://www.vatlive.com/vat-rates/european-vat-rates/eu-vat-rates/)\n   * Oh, and we also have the USA, where we need to worry about each state...\n\nDo this:\n\n```JavaScript\n\n// queries return a function, in case there is some\n// really custom logic (and there is, see US, NY below)\n// in the normal case, just pass the rate back out with\n// an identity function\n// also record the rate for custom printing later\nfunction I(val) { var rate = function(){return val}; rate.val=val; return rate }\n\n\nvar salestax = patrun()\nsalestax\n  .add({}, I(0.0) )\n\n  .add({ country:'IE' }, I(0.25) )\n  .add({ country:'UK' }, I(0.20) )\n  .add({ country:'DE' }, I(0.19) )\n\n  .add({ country:'IE', type:'reduced' }, I(0.135) )\n  .add({ country:'IE', type:'food' },    I(0.048) )\n\n  .add({ country:'UK', type:'food' },    I(0.0) )\n\n  .add({ country:'DE', type:'reduced' }, I(0.07) )\n\n  .add({ country:'US' }, I(0.0) ) // no federeal rate (yet!)\n\n  .add({ country:'US', state:'AL' }, I(0.04) ) \n  .add({ country:'US', state:'AL', city:'Montgomery' }, I(0.10) ) \n\n  .add({ country:'US', state:'NY' }, I(0.07) ) \n  .add({ country:'US', state:'NY', type:'reduced' }, function under110(net){\n    return net < 110 ? 0.0 : salestax.find( {country:'US', state:'NY'} )\n  }) \n\n\nconsole.log('Default rate: ' + \n            salestax.find({})(99) )\n\nconsole.log('Standard rate in Ireland on E99: ' + \n            salestax.find({country:'IE'})(99) )\n\nconsole.log('Food rate in Ireland on E99:     ' + \n            salestax.find({country:'IE',type:'food'})(99) )\n\nconsole.log('Reduced rate in Germany on E99:  ' + \n            salestax.find({country:'IE',type:'reduced'})(99) )\n\nconsole.log('Standard rate in Alabama on $99: ' + \n            salestax.find({country:'US',state:'AL'})(99) )\n\nconsole.log('Standard rate in Montgomery, Alabama on $99: ' + \n            salestax.find({country:'US',state:'AL',city:'Montgomery'})(99) )\n\nconsole.log('Reduced rate in New York for clothes on $99: ' + \n            salestax.find({country:'US',state:'NY',type:'reduced'})(99) )\n\n\n// prints:\n// Default rate: 0\n// Standard rate in Ireland on E99: 0.25\n// Food rate in Ireland on E99:     0.048\n// Reduced rate in Germany on E99:  0.135\n// Standard rate in Alabama on $99: 0.04\n// Standard rate in Montgomery, Alabama on $99: 0.1\n// Reduced rate in New York for clothes on $99: 0\n```\n\nYou can take a look a the decision tree at any time:\n\n```JavaScript\n\n// print out patterns, using a custom format function\nconsole.log(salestax.toString( function(f){return f.name+':'+f.val} ))\n\n\n// prints:\n -> :0\ncity=Montgomery, country=US, state=AL -> :0.1\ncountry=IE -> :0.25\ncountry=IE, type=reduced -> :0.135\ncountry=IE, type=food -> :0.048\ncountry=UK -> :0.2\ncountry=UK, type=food -> :0\ncountry=DE -> :0.19\ncountry=DE, type=reduced -> :0.07\ncountry=US -> :0\ncountry=US, state=AL -> :0.04\ncountry=US, state=NY -> :0.07\ncountry=US, state=NY, type=reduced -> under110:undefined\n```\n\n\n# The Rules\n\n   * 1: More specific matches beat less specific matches. That is, more property values beat fewer.\n   * 2: Property names are checked in alphabetical order.\n\nAnd that's it.\n\n\n# Customization\n\nYou can customize the way that data is stored. For example, you might want to add a constant property to each pattern.\n\nTo do this, you provide a custom function when you create the _patrun_ object:\n\n```JavaScript\nvar alwaysAddFoo = patrun( function(pat){\n  pat.foo = true\n})\n\nalwaysAddFoo.add( {a:1}, \"bar\" )\n    \nalwaysAddFoo.find( {a:1} ) // nothing!\nalwaysAddFoo.find( {a:1,foo:true} ) // == \"bar\"\n```\n\nYour custom function can also return a modifer function for found\ndata, and optionally a modifier for removing data.\n\nHere's a example that modifies found data:\n\n```JavaScript\nvar upperify = patrun( function(pat){\n  return function(args,data) {\n    return (''+data).toUpperCase()\n  }\n})\n\nupperify.add( {a:1}, \"bar\" )\n    \nupperify.find( {a:1} ) // BAR\n```\n\nFinally, here's an example that allows you to add multiple matches for a given pattern:\n\n```JavaScript\nvar many = patrun( function(pat,data){\n  var items = this.find(pat,true) || []\n  items.push(data)\n\n  return {\n    find: function(args,data){\n      return 0 < items.length ? items : null\n    },\n    remove: function(args,data){\n      items.pop()\n      return 0 == items.length;\n    }\n  }\n})\n\nmany.add( {a:1}, 'A' )\nmany.add( {a:1}, 'B' )\nmany.add( {b:1}, 'C' )\n\nmany.find( {a:1} ) // [ 'A', 'B' ]\nmany.find( {b:1} ) // [ 'C' ]\n\nmany.remove( {a:1} ) \nmany.find( {a:1} ) // [ 'A' ]\n\nmany.remove( {b:1} ) \nmany.find( {b:1} ) // null\n```\n\n\n# API\n\n## patrun( custom )\n\nGenerates a new pattern matcher instance. Optionally provide a customisation function.\n\n\n## .add( {...pattern...}, object )\n\nRegister a pattern, and the object that will be returned if an input matches.\n\n\n## .find( {...pattern...} )\n\nReturn the unique match for this pattern, or null if not found\n\n\n## .list( {...pattern...} )\n\nReturn the list of matches for this pattern. You can use wildcards for property values. \nOmitted values are *not* equivalent to a wildcard of _\"*\"_, you must specify each property explicitly.\n\n```JavaScript\npm = patrun()\n  .add({a:1,b:1},'B1')\n  .add({a:1,b:2},'B2')\n\n// finds nothing: []\nconsole.log( pm.list({a:1}) )\n\n// finds:\n// [ { match: { a: '1', b: '1' }, data: 'B1' },\n//   { match: { a: '1', b: '2' }, data: 'B2' } ]\nconsole.log( pm.list({a:1,b:'*'}) )\n```\n\nIf you provide no pattern argument at all, _list_ will list all patterns that have been added.\n```JavaScript\n// finds everything\nconsole.log( pm.list() )\n```\n\n## .remove( {...pattern...} )\n\nRemove this pattern, and it's object, from the matcher.\n\n\n## .toString( func, tree )\n\nGenerate a string representation of the decision tree for debugging. Optionally provide a formatting function for objects.\n\n   * func: format function for data, optional\n   * tree: boolean flag, if true, print an indented tree rather than a list of patterns, default: false\n\n## .toJSON( indent )\n\nGenerate JSON representation of the tree.\n\n\n# Development\n\nFrom the Irish patr&uacute;n: [pattern](http://www.focloir.ie/en/dictionary/ei/pattern). Pronounced _pah-troon_.\n\nsudo npm install phantomjs@1.9.1-0 uglify-js -g\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rjrodger/patrun/issues"
  },
  "_id": "patrun@0.2.0",
  "dist": {
    "shasum": "1b1655c507bcba831f9a8612631762f4efec8a9e"
  },
  "_from": "patrun@~0.2.0",
  "_resolved": "http://registry.npmjs.org/patrun/-/patrun-0.2.0.tgz"
}
